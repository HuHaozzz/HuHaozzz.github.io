<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <!--<link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">-->
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="Flux RSS"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Rechercher"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-下沉市场模式解析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/07/下沉市场模式解析/" class="article-date">
  <time datetime="2020-06-07T11:28:05.000Z" itemprop="datePublished">2020-06-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/07/下沉市场模式解析/">下沉市场模式解析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>定义：五环以外的市场，以及三线城市和三线城市以下的市场。<br>特点：人口基数大（国内超过十亿）<br>例子：1. 拼多多，创立三年上市，市值和京东相仿；2. 趣头条，创立两年零三月上市；3.快手，估值超过200亿刀 4.水滴筹，估值超过10亿 5.云集（赚钱模式是拉下线，下线购物和销售自己能拿到佣金的百分之10）</p>
<p>第一个挑战：现在了解市场不再是通过人的经验，而是通过人工智能和数据分析<br>第二个挑战：自己不一定要是自己产品的用户（比如张一鸣不一定用今日头条）<br>底层逻辑本质不在于了解用户，而在于：1.数据分析 2. 建立商业模型<br>产品各行业举例：电商拼多多；搜索百度；游戏有专门针对的产品；社交微信；OYO连锁酒店<br>产品创始人举例：做下沉市场最牛的人都不是在三四线城市出生，而是在北京上海；都不是草根出生，而是高学历高智商。</p>
<ul>
<li>拼多多黄峥天才少年， </li>
<li>快手宿华清华博士退学，曾任职google百度 </li>
<li>趣头条CEO谭思亮清华本科，曾任雅虎盛大高管。</li>
</ul>
<p>大局上看共性：<br>下沉市场人口超10亿，大部分的家庭月收入不足3000，<br>但是</p>
<ol>
<li>可支配收入不低，因为开支不多 </li>
<li>广告价值不低 </li>
<li>闲暇时间多达六小时</li>
<li>没有品牌概念买东西图实惠，很多人根本不知道自己的电视品牌，手机持有率0.5 </li>
<li>手机拥有率和App下载率低，扫码下载不现实，多为朋友帮忙装</li>
<li>对品质要求不高，对价格敏感 </li>
<li>通勤时间短，15min内（所以原本针对通勤时间听的知识付费类产品难以攻入）</li>
</ol>
<p>面对一线城市做，需要帮他们节约时间，提高效率；<br>面对下沉市场做，需要帮他们消磨时间，过得快乐。<br>总之：</p>
<ol>
<li>有红利，获客成本低，获得用户方式：拼团、收徒、人拉人给补贴。（但补贴只是降低获客成本的方法）</li>
<li>建立合适的商业模型变现。比如使用周期中看多少条广告（带来利润）+留存+拉人头+裂变；算得，如果用户在半年内如果能给公司赚6毛，那我就能拿出3毛来分给用户。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/07/下沉市场模式解析/" data-id="ckb5166ai000hlsvwgj3bvdnz" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-c++ 实现最大堆和最小堆" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/07/c++ 实现最大堆和最小堆/" class="article-date">
  <time datetime="2020-06-07T11:26:32.000Z" itemprop="datePublished">2020-06-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/07/c++ 实现最大堆和最小堆/">c++实现最大堆和最小堆</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>堆是具有以下特性的<em>完全二叉树</em>，每个结点的值都大于或等于其左右孩子结点的值，叫做最大堆；每个结点的值都小于或等于其左右孩子结点的值，叫做最小堆。</p>
<h1 id="一、用vector和push-heap、pop-heap实现堆"><a href="#一、用vector和push-heap、pop-heap实现堆" class="headerlink" title="一、用vector和push_heap、pop_heap实现堆"></a>一、用vector和push_heap、pop_heap实现堆</h1><h2 id="（1）建堆"><a href="#（1）建堆" class="headerlink" title="（1）建堆"></a>（1）建堆</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums = &#123;<span class="number">9</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</div></pre></td></tr></table></figure>
<p>1、如果使用nums构建最大堆：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">make_heap(nums.begin(), nums.end());</div><div class="line"><span class="comment">//或</span></div><div class="line">make_heap(nums.begin(), nums.end(), less&lt;<span class="keyword">int</span>&gt;());</div></pre></td></tr></table></figure>
<p>输出nums的结果为</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//最大堆是按照层序遍历的顺序存入vector的</span></div><div class="line"><span class="number">9</span> <span class="number">8</span> <span class="number">2</span> <span class="number">6</span> <span class="number">7</span> <span class="number">0</span> <span class="number">1</span> <span class="number">4</span> <span class="number">3</span> <span class="number">5</span></div></pre></td></tr></table></figure>
<p>2、如果使用nums构建最小堆：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">make_heap(nums.begin(), nums.end(), greater&lt;<span class="keyword">int</span>&gt;());</div></pre></td></tr></table></figure>
<p>输出nums的结果为</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span> <span class="number">3</span> <span class="number">1</span> <span class="number">4</span> <span class="number">5</span> <span class="number">2</span> <span class="number">9</span> <span class="number">8</span> <span class="number">6</span> <span class="number">7</span></div></pre></td></tr></table></figure>
<h2 id="（2）调整堆"><a href="#（2）调整堆" class="headerlink" title="（2）调整堆"></a>（2）调整堆</h2><p>当使用上述的make_heap()建完堆后，如果vector使用push_back()插入数据或pop_back()删除数据后，会破坏最大堆/最小堆的性质，所以需要调整堆，常用push_heap()和pop_heap()两个方法</p>
<p>1、push_heap()用法是，vector先push_back()，后push_heap()：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">nums.push_back(<span class="number">10</span>);</div><div class="line">push_heap(nums.begin(), nums.end(), less&lt;<span class="keyword">int</span>&gt;());</div></pre></td></tr></table></figure>
<p>输出nums的结果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//原vector </span></div><div class="line"><span class="number">9</span> <span class="number">8</span> <span class="number">2</span> <span class="number">6</span> <span class="number">7</span> <span class="number">0</span> <span class="number">1</span> <span class="number">4</span> <span class="number">3</span> <span class="number">5</span> </div><div class="line"><span class="comment">//push_back()后</span></div><div class="line"><span class="number">9</span> <span class="number">8</span> <span class="number">2</span> <span class="number">6</span> <span class="number">7</span> <span class="number">0</span> <span class="number">1</span> <span class="number">4</span> <span class="number">3</span> <span class="number">5</span> <span class="number">10</span></div><div class="line"><span class="comment">//push_heap()后</span></div><div class="line"><span class="number">10</span> <span class="number">9</span> <span class="number">2</span> <span class="number">6</span> <span class="number">8</span> <span class="number">0</span> <span class="number">1</span> <span class="number">4</span> <span class="number">3</span> <span class="number">5</span> <span class="number">7</span></div></pre></td></tr></table></figure>
<p>2、pop_heap()用法是，先pop_heap()，vector后pop_back()：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pop_heap(nums.begin(), nums.end(), less&lt;<span class="keyword">int</span>&gt;());</div><div class="line">nums.pop_back();</div></pre></td></tr></table></figure>
<p>输出nums的结果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//原vector</span></div><div class="line"><span class="number">9</span> <span class="number">8</span> <span class="number">2</span> <span class="number">6</span> <span class="number">7</span> <span class="number">0</span> <span class="number">1</span> <span class="number">4</span> <span class="number">3</span> <span class="number">5</span> </div><div class="line"><span class="comment">//pop_heap()后</span></div><div class="line"><span class="number">8</span> <span class="number">7</span> <span class="number">2</span> <span class="number">6</span> <span class="number">5</span> <span class="number">0</span> <span class="number">1</span> <span class="number">4</span> <span class="number">3</span> <span class="number">9</span> </div><div class="line"><span class="comment">//pop_back()后</span></div><div class="line"><span class="number">8</span> <span class="number">7</span> <span class="number">2</span> <span class="number">6</span> <span class="number">5</span> <span class="number">0</span> <span class="number">1</span> <span class="number">4</span> <span class="number">3</span></div></pre></td></tr></table></figure>
<p><strong>为什么pop_heap()的用法要反过来呢？</strong><br>要从我们的目的来考虑，使用pop_heap()的绝大部分目的是要把堆顶元素pop出堆中，因为它最大或最小。如果先用vector的pop_back()，它删除的不是堆顶元素（nums[0]），而是vector的最后一个元素。可见这不是我们想要的结果：对于最大堆，最后一个元素既不是最大，也不一定是最小；对于最小堆，最后一个元素既不是最小，也不一定是最大。pop出来没有意义。<br><strong>观察pop_heap()对堆做了什么？</strong><br>pop_heap()把堆顶元素放到了最后一位，然后对它前面的数字重建了堆。这样一来只要再使用pop_back()把最后一位元素删除，就得到了新的堆。</p>
<h1 id="二、用priority-queue实现堆"><a href="#二、用priority-queue实现堆" class="headerlink" title="二、用priority_queue实现堆"></a>二、用priority_queue实现堆</h1><p><strong>priority_queue</strong><br>对于这个模板类priority_queue，它是STL所提供的一个非常有效的容器。<br>作为队列的一个延伸，优先队列包含在头文件 <queue> 中。</queue></p>
<h2 id="（1）简述"><a href="#（1）简述" class="headerlink" title="（1）简述"></a>（1）简述</h2><p>优先队列时一种比较重要的数据结构，它是有二项队列编写而成的，可以以<strong>O(log n)</strong> 的效率查找一个队列中的最大值或者最小值，其中是最大值还是最小值是根据<strong>创建的优先队列的性质来决定的</strong>。</p>
<h2 id="（2）模板参数"><a href="#（2）模板参数" class="headerlink" title="（2）模板参数"></a>（2）模板参数</h2><p>优先队列有三个参数，其声明形式为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">priority_queue&lt; type, container, function &gt;</div></pre></td></tr></table></figure>
<p>这三个参数，后面两个可以省略，第一个不可以。<br>其中：</p>
<ol>
<li><strong>type</strong>：数据类型； </li>
<li><strong>container</strong>：实现优先队列的底层容器； </li>
<li><strong>function</strong>：元素之间的比较方式；</li>
</ol>
<p>对于<strong>container</strong>，要求必须是<strong>数组形式实现的容器</strong>，例如vector、deque，而不能使list。<br>在STL中，默认情况下（不加后面两个参数）是以<strong>vector</strong>为容器，以 <strong>operator&lt;</strong> 为比较方式，所以在只使用第一个参数时，优先队列默认是一个<strong>最大堆</strong>，每次输出的堆顶元素是此时堆中的最大元素。</p>
<h2 id="（3）成员函数"><a href="#（3）成员函数" class="headerlink" title="（3）成员函数"></a>（3）成员函数</h2><p>假设type类型为<strong>int</strong>，则：</p>
<ol>
<li><strong>bool empty() const</strong><br>返回值为true，说明队列为空； </li>
<li><strong>int size() const</strong><br>返回优先队列中元素的数量；</li>
<li><strong>void pop()</strong><br>删除队列顶部的元素，也即根节点 </li>
<li><strong>int top()</strong><br>返回队列中的顶部元素，但不删除该元素； </li>
<li><strong>void push(int arg)</strong><br>将元素arg插入到队列之中；</li>
</ol>
<h2 id="（4）大顶堆和小顶堆"><a href="#（4）大顶堆和小顶堆" class="headerlink" title="（4）大顶堆和小顶堆"></a>（4）大顶堆和小顶堆</h2><ul>
<li>大顶堆</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//构造一个空的优先队列（此优先队列默认为大顶堆）</span></div><div class="line">priority_queue&lt;<span class="keyword">int</span>&gt; big_heap;   </div><div class="line"></div><div class="line"><span class="comment">//另一种构建大顶堆的方法</span></div><div class="line">priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,less&lt;<span class="keyword">int</span>&gt; &gt; big_heap2;</div></pre></td></tr></table></figure>
<ul>
<li>小顶堆</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//构造一个空的优先队列,此优先队列是一个小顶堆</span></div><div class="line">priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt; small_heap;</div></pre></td></tr></table></figure>
<p>需要注意的是，如果使用<code>less&lt;int&gt;</code>和<code>less&lt;int&gt;</code>，需要头文件：<br><code>#include &lt;functional&gt;</code></p>
<p>转载自文章<br><a href="https://www.jianshu.com/p/13a56502e217" target="_blank" rel="external">c++使用vector建立最大堆和最小堆
</a></p>
<p><a href="https://blog.csdn.net/lym940928/article/details/89635690" target="_blank" rel="external">C++中priority_queue理解与使用
</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/07/c++ 实现最大堆和最小堆/" data-id="ckb5166a20009lsvwqmuhcssc" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-C++ string的substr操作需要注意的地方" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/07/C++ string的substr操作需要注意的地方/" class="article-date">
  <time datetime="2020-06-07T11:25:25.000Z" itemprop="datePublished">2020-06-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/07/C++ string的substr操作需要注意的地方/">C++string的substr操作需要注意的地方</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>s.substr(pos,n)</p>
<p>返回一个string，包含s中从pos开始的n个字符的拷贝。pos的默认值为0，n的默认值为s.size()-pos，即拷贝从pos开始的所有字符。</p>
<p>需要注意的是pos不能越界，pos+n可以越界。如果开始位置pos超过了string的大小，则substr函数会抛出一个out_of_range异常。如果开始位置pos加上计数值n大于string的大小，则substr会调整计数值，只拷贝到string的末尾。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/07/C++ string的substr操作需要注意的地方/" data-id="ckb5166970001lsvwqqt2vknv" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-压缩感知SL0图像重建算法的opencv实现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/07/压缩感知SL0图像重建算法的opencv实现/" class="article-date">
  <time datetime="2020-06-07T11:23:39.000Z" itemprop="datePublished">2020-06-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/07/压缩感知SL0图像重建算法的opencv实现/">压缩感知SL0图像重建算法的opencv实现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近研究生的项目中涉及到压缩感知的SL0图像重建算法，需要对其进行C++实现。</p>
<p>按照压缩感知的理论框架，可以将它分为三个部分：图像的稀疏表示，即寻找一个正交基使原始图像尽可能的稀疏，图像的稀疏表示越充分，就越有利于图像的重建；测量矩阵的设计，为了重构稀疏信号，编码采样测量矩阵必须满足约束等距性RIP(Restricted isometry property)条件， 即将编码采样视为对原有信号的一种映射变换；图像重建，即通过测量信号重构原始信号。</p>
<p>重建算法相当于信号测量过程的逆过程，设一个长度为N的原始信号经过测量矩阵得到一个长度为M(M&lt;N)的测量值信号，高分辨率成像重建的过程是通过测量向量y重构原始信号x的过程，由于方程个数远少于求解未知量个数，必须解一个欠定方程，很难直接求解。但由于原始信号是稀疏的或者能够稀疏表示，所以通常会加一个稀疏表达作为正则项，而稀疏表达通常用求解最小L0范数的方式加以表示，如下式所示：</p>
<p>$$<br>\hat{x}=\arg \min |x|_{0} \quad \text { s.t. } \quad \Phi x=y<br>$$</p>
<p>但求解最小L0范数通常很困难，是一个NP难问题，比如长度为N的稀疏信号中有K个非零值，则稀疏信号有$\mathrm{C}_{\mathrm{N}}^{\mathrm{K}}$种排列可能，要找到最接近于原始信号的最优排列，计算复杂度非常高。因此为了高分辨率成像重建的高效进行，常常会规避零范数问题，比如会选择以最小L1范数法为代表的次最优解算法以及以正交匹配追踪算法为代表的的贪婪算法进行求解，此外还常用迭代阈值法和最小全变分法。也可以用一种渐近逼近L0范数的高分辨率成像重建算法，通过渐近化解非凸优化求解的困难，通过L0约束确保信号的稀疏度。</p>
<p>信号重构算法是指由长度为M测量向量的y重构长度为N(M&lt;N)的稀疏信号s的过程。</p>
<p>$$<br>\hat{\mathrm{s}}=\operatorname{argmin}|\mathrm{x}|_{0} \quad \text { s.t. } \mathrm{y}=\Theta \mathrm{s}<br>$$</p>
<p>项目中涉及到的SL0算法是由最小L2范数向最小L0范数的逐渐逼近，上式中Θ是传感矩阵，$|\mathrm{x}|_{0}$表示的是L0范数，研究首先定义一个逼近函数模型：</p>
<p>$$<br>\mathrm{f}<em>{\sigma}(s)=1-\exp \left(-s^{2} / 2 \sigma^{2}\right) \quad \mathrm{f}</em>{\sigma}\left(s<em>{i}\right)=1-\exp \left(-s</em>{i}^{2} / 2 \sigma^{2}\right)<br>$$</p>
<p>从而有$\mathrm{F}<em>{\sigma}(\mathrm{s})=\sum</em>{\mathrm{i}=1}^{\mathrm{n}} \mathrm{f}<em>{\sigma}\left(\mathrm{s}</em>{\mathrm{i}}\right)$，其中，n为稀疏信号向量s的长度，si为稀疏信号向量s对应的第i个元素，σ为逼近L0范数的调制参数，$\mathrm{F}<em>{\sigma}(\mathrm{s})$近似表示s非零较大项的数目。逼近函数$\mathrm{f}</em>{\sigma}\left(\mathrm{s}<em>{\mathrm{i}}\right)$和$\mathrm{s}</em>{\mathrm{i}}$、σ的关系如下图所示：</p>
<div align="center"><img src="https://img-blog.csdnimg.cn/20191206112412956.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MjMxNzEz,size_16,color_FFFFFF,t_70"></div>

<p>当σ较大时，$\mathrm{F}<em>{\sigma}(\mathrm{s})$可以近似表示为L2范数。根据渐进思想，当σ取值逐渐减小时，$\mathrm{F}</em>{\sigma}(\mathrm{s})$逐渐逼近L0范数，向量s的L0范数准则的优化问题可近似表示为$|\mathrm{s}|<em>{0}=\mathrm{F}</em>{\sigma}(\mathrm{s})$。另外从上图可知，由于逼近的L0范数的函数曲线是光滑可导的，因此被称为逼近光滑L0范数算法（简称为SL0）。</p>
<p>由此，稀疏表示$|\mathrm{x}|<em>{0}$极小问题，转化为连续函数$\mathrm{F}</em>{\sigma}(\mathrm{s})$的极小。从而重建式转化为一种全新的稀疏表示模型：</p>
<p>$$<br>\hat{\mathbf{s}}=\arg \min \mathrm{F}_{\sigma}(\mathrm{s}) \text { s.t } \Theta \mathrm{s}=\mathrm{y}<br>$$</p>
<p>此模型通常只针对于普通的稀疏表示，对于图像重构这一类的逆问题，稀疏表示通常用来作为先验正则项，所以为了求解图像重构问题的最优解，增加了一个重构逼近项的约束优化问题。在模型的基础上，增加了重构的残差项，进而形成了光滑L0范数稀疏表示加误差逼近的完整的压缩感知图像重构模型： </p>
<p>$$<br>\mathrm{J}(\mathrm{s})=\arg \min \left{\mathrm{F}<em>{\sigma}(\mathrm{s})+\lambda|\Theta \mathrm{s}-\mathrm{y}|</em>{2}^{2}\right}<br>$$</p>
<p>式中λ为权重平衡参数。上述模型中的稀疏表示先验项以稀疏信号s为处理内容，而误差逼近项是重构图像投影测量值与实际值的残差极小为整幅图像的全局优化。由于是逼近最小L0范数的算法求解方式，$\mathrm{F}<em>{\sigma}(\mathrm{s})$中的σ参数是逐步减小的，因此逼近最小L0范数稀疏表示的优化问题可采用梯度下降的迭代计算方式来解决，即对式中s进行求导，在梯度方向$\Delta \mathrm{J}(\mathrm{s})$进行迭代：<br>$$<br>\Delta J(s)=d=2 \lambda\left(\Theta^{T}(\Theta s-y)\right)+\left(1 / \sigma^{2}\right)^{*}\left[s</em>{1} \exp \left(-s<em>{i}^{2} \sigma^{2} / 2\right), \cdots, s</em>{m} \exp \left(-s_{m}^{2} \sigma^{2} / 2\right)\right]^{\mathrm{T}}<br>$$</p>
<p>基于梯度下降的逼近最小L0范数算法的伪代码过程如下：<br>1) 变量名的物理含义：传感矩阵Θ，测量值y，原始信号的稀疏表示s；<br>2) 初始化：$\hat{\mathrm{s}}<em>{0}=\Theta^{\perp} \mathrm{y}, \Theta^{\perp}$为Θ的伪逆阵，$\Theta^{\perp}=\left(\Theta^{\mathrm{T}} \Theta\right)^{-1} \Theta^{\mathrm{T}}$，设增长序列$\sigma=\left[\sigma</em>{1}, \ldots, \sigma<em>{k}\right]$、λ和梯度下降步长µ；<br>3) 循环σ序列k：<br>a) $\sigma=\sigma</em>{\mathrm{k}}, \quad \widehat{\mathrm{s}}=\widehat{\mathrm{s}}<em>{\mathrm{k}-1}$；<br>b) 梯度下降法迭代L次：<br>a.梯度下降方向：<br>$$<br>d=2 \lambda\left(\Theta^{T}(\Theta s-y)\right)+\left(1 / \sigma^{2}\right)^{*}\left[s</em>{1} \exp \left(-s<em>{i}^{2} \sigma^{2} / 2\right), \cdots, s</em>{m} \exp \left(-S<em>{m}^{2} \sigma^{2} / 2\right)\right]^{\mathrm{T}}<br>$$b.梯度方向更新：$\widehat{\mathrm{s}}=\widehat{\mathrm{s}}-\mu \mathrm{d}$<br>c.约束正交投影：$\widehat{\mathrm{s}}=\widehat{\mathrm{s}}-\Theta^{\perp}(\Theta \widehat{\mathrm{s}}-\mathrm{y})$<br>c) $\hat{\mathrm{s}}</em>{\mathrm{k}}=\hat{\mathrm{s}}, \quad \mathrm{k}=\mathrm{k}+1$；<br>4) 结束循环：输出$\widehat{\mathrm{s}}_{\mathrm{k}}$为最终求得的稀疏信号s。 </p>
<p>值得注意的是，在算法求解过程中，随着迭代的进行，误差$|\Theta s-y|<em>{2}^{2}$越来越小，使稀疏表示正则项$\mathrm{F}</em>{\sigma}(\mathrm{s})=\sum<em>{\mathrm{i}=1}^{\mathrm{n}} \mathrm{f}</em>{\sigma}\left(\mathrm{s}<em>{\mathrm{i}}\right)$越来越逼近于L0范数，同时可以让误差$|\Theta s-y|</em>{2}^{2}$所占权重逐渐减小，逼近L0范数的稀疏表示正则项$\mathrm{F}<em>{\sigma}(\mathrm{s})$所占权重逐渐增大。因此λ设置成递增序列，σ设置成递减序列，从而在迭代过程中可以根据误差$|\Theta s-y|</em>{2}^{2}$的大小能够自适应地去调整λ和σ的值。</p>
<p>由逼近图可知，随着σ的逐渐减小，稀疏表示正则项$\mathrm{F}_{\sigma}(\mathrm{s})$越来越光滑地逼近近似的L0范数，在逐渐降低了重构稀疏信号的稀疏度的同时以更大效率逐渐逼近我们需要的全局最优解，从而降低了算法复杂度和提高了图像重建的精度，从而更加利于高分辨率图像的重建。</p>
<p><strong>简单的实验验证</strong></p>
<p>例如对于矩阵的乘法$\Theta^{*} \mathrm{s}=y$</p>
<p>$$<br>\left[\begin{array}{ccccc}{0.245} &amp; {-0.053} &amp; {4.478} &amp; {-3.426} &amp; {3.487} &amp; {2.85} \ {-1.205} &amp; {3.42} &amp; {-2.39} &amp; {-2.752} &amp; {4.49} &amp; {11.676}\end{array}\right] *\left[\begin{array}{c}{0} \ {0} \ {-8.361} \ {0} \ {0} \ {-12.982}\end{array}\right]=\left[\begin{array}{c}{-74.4383} \ {-131.5950}\end{array}\right]<br>$$</p>
<p>其中Θ为传感矩阵，s为原始信号在变换域中的稀疏表达，y为维度更低的测量信号。由2维的y来恢复6维的s是一个欠定问题，但如测量矩阵满足RIP条件，将s的稀疏性作为正则项，就有较大的概率重构出原始信号。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></div><div class="line">&#123;</div><div class="line">	Mat A = (Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">2</span>, <span class="number">6</span>) &lt;&lt; <span class="number">0.245f</span>, <span class="number">-0.053</span>f, <span class="number">4.478f</span>, <span class="number">-3.426</span>f, <span class="number">3.487f</span>, <span class="number">2.85f</span>, </div><div class="line">							       <span class="number">-1.205</span>f, <span class="number">3.42f</span>, <span class="number">-2.39</span>f, <span class="number">-2.752</span>f, <span class="number">4.49f</span>, <span class="number">11.676f</span>);</div><div class="line">	Mat y = (Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">2</span>, <span class="number">1</span>) &lt;&lt; <span class="number">-74.4393</span>f, <span class="number">-131.5950</span>f);</div><div class="line">	<span class="function">Mat <span class="title">s</span><span class="params">(<span class="number">6</span>, <span class="number">1</span>, CV_64FC1)</span></span>;</div><div class="line">	<span class="comment">/*sigma_min为sigma迭代终止的条件，sigma_min越小，重构结果就越精确*/</span></div><div class="line">	<span class="keyword">double</span> sigma_min = <span class="number">0.001</span>;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (SL0(A, y, sigma_min, s))</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"传感矩阵为："</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; A &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;;</div><div class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"生成向量为："</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; y &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;;</div><div class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"重构出更高维的原始向量的稀疏表示为："</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span></div><div class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error in calling SL0 function.\nsigma_min = %f"</span>, </div><div class="line">				sigma_min);</div><div class="line"></div><div class="line">	system(<span class="string">"pause"</span>);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>验证结果为</p>
<center><img src="https://img-blog.csdnimg.cn/20191206152025928.png"></center>


<p>SL0算法的实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MyDelta</span><span class="params">(<span class="keyword">const</span> Mat s, <span class="keyword">const</span> <span class="keyword">double</span> sigma, Mat &amp;delta)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.rows; ++i)</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s.cols; ++j)</div><div class="line">			delta.at&lt;<span class="keyword">double</span>&gt;(i, j)  = s.at&lt;<span class="keyword">double</span>&gt;(i, j) *</div><div class="line">			<span class="built_in">exp</span>(<span class="number">-1</span> * s.at&lt;<span class="keyword">double</span>&gt;(i, j) * s.at&lt;<span class="keyword">double</span>&gt;(i, j) / (<span class="number">2</span> * sigma * sigma));</div><div class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SL0</span><span class="params">(<span class="keyword">const</span> Mat A, <span class="keyword">const</span> Mat y, <span class="keyword">const</span> <span class="keyword">double</span> sigma_min, Mat &amp;s)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">double</span> iteration_factor = <span class="number">0.5</span>;</div><div class="line">	<span class="keyword">double</span> lamdba = <span class="number">0.1</span>;</div><div class="line">	<span class="keyword">double</span> sigma;</div><div class="line">	<span class="keyword">int</span> mu_0 = <span class="number">2</span>;</div><div class="line">	<span class="keyword">int</span> L = <span class="number">3</span>;</div><div class="line">	</div><div class="line">	<span class="comment">//A_pinv为矩阵A的伪逆</span></div><div class="line">	Mat A_pinv;</div><div class="line">	invert(A, A_pinv, cv::DECOMP_SVD);</div><div class="line">	</div><div class="line">	<span class="comment">//向量s和增长序列sigma的初始化</span></div><div class="line">	s = A_pinv * y;</div><div class="line">	<span class="keyword">double</span> minVal, maxVal;</div><div class="line">	minMaxLoc(s, &amp;minVal, &amp;maxVal);</div><div class="line">	sigma = <span class="built_in">abs</span>(minVal) &gt; <span class="built_in">abs</span>(maxVal) ? <span class="built_in">abs</span>(minVal) : <span class="built_in">abs</span>(maxVal);</div><div class="line">	sigma *= <span class="number">2</span>;</div><div class="line"></div><div class="line">	<span class="comment">//到达指定的停机准则就退出，siama_min越小，重建结果越精确</span></div><div class="line">	<span class="keyword">while</span> (sigma &gt; sigma_min)</div><div class="line">	&#123;</div><div class="line">		<span class="comment">//迭代下降法迭代L次</span></div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != L; ++ i)</div><div class="line">		&#123;</div><div class="line">			<span class="comment">//delta为梯度下降方向</span></div><div class="line">			Mat delta = Mat::zeros(s.size(), s.type());</div><div class="line"></div><div class="line">			<span class="keyword">if</span> (MyDelta(s, sigma, delta))</div><div class="line">				delta += <span class="number">2</span> * lamdba * (A.t() * (A * s - y));</div><div class="line">			<span class="keyword">else</span></div><div class="line">				<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error in calculating delta"</span>);</div><div class="line">			s = s - mu_0 * delta;		<span class="comment">//梯度方向更新</span></div><div class="line">			s = s - A_pinv * (A * s - y);		<span class="comment">//约束正交投影</span></div><div class="line"></div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">//迭代过程中，误差所占权重逐渐减小，自适应的调整lamdba和siama的值</span></div><div class="line">		sigma = sigma * iteration_factor;</div><div class="line">		lamdba = lamdba * (<span class="number">1</span> / iteration_factor);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/07/压缩感知SL0图像重建算法的opencv实现/" data-id="ckb5166ax000llsvww3cqmuzx" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-矩阵伪逆的opencv实现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/07/矩阵伪逆的opencv实现/" class="article-date">
  <time datetime="2020-06-07T11:22:13.000Z" itemprop="datePublished">2020-06-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/07/矩阵伪逆的opencv实现/">矩阵伪逆的opencv实现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>1、矩阵的逆</strong><br>定义：<br>设A是数域上的一个n阶方阵，若在相同数域上存在另一个n阶矩阵B，使得： AB=BA=I。 则我们称B是A的逆矩阵，而A则被称为可逆矩阵。</p>
<p>可逆条件：<br>A是可逆矩阵的充分必要条件是，即可逆矩阵就是非奇异矩阵。（当 时，A称为奇异矩阵）</p>
<p>性质：<br>-矩阵A可逆的充要条件是A的行列式不等于0。<br>-可逆矩阵一定是方阵。<br>-如果矩阵A是可逆的，A的逆矩阵是唯一的。<br>-可逆矩阵也被称为非奇异矩阵、满秩矩阵。<br>-两个可逆矩阵的乘积依然可逆。<br>-可逆矩阵的转置矩阵也可逆。<br>-矩阵可逆当且仅当它是满秩矩阵。</p>
<p><strong>2、矩阵的伪逆</strong><br>伪逆矩阵：<br>伪逆矩阵是逆矩阵的广义形式。由于奇异矩阵或非方阵的矩阵不存在逆矩阵，但在matlab里可以用函数pinv(A)求其伪逆矩阵。基本语法为X=pinv(A),X=pinv(A,tol),其中tol为误差,pinv为pseudo-inverse的缩写：max(size(A))<em>norm(A)</em>eps。函数返回一个与A的转置矩阵A’ 同型的矩阵X，并且满足：AXA=A,XAX=X.此时，称矩阵X为矩阵A的伪逆，也称为广义逆矩阵。pinv(A)具有inv(A)的部分特性，但不与inv(A)完全等同。如果A为非奇异方阵，pinv(A)=inv(A)，但却会耗费大量的计算时间，相比较而言，inv(A)花费更少的时间。</p>
<p><strong>3、opencv函数invert（）介绍</strong></p>
<p>double invert(InputArray src, OutputArraydst, int flags=DECOMP_LU);</p>
<p>功能：用以求取一个矩阵的逆或者伪逆。</p>
<p>src： 输入，浮点型（32位或者64位）的M×N的矩阵，当参数3的使用方法为DECOMP_CHOLESKY  DECOMP_LU  DECOMP_EIG时函数功能为求逆，此时需保证M=N（参见参数flag）。</p>
<p>dst： 输出，与输入矩阵类型一致的N×M的矩阵。</p>
<p>flag：求逆方法，提供4种可选择的方法：DECOMP_CHOLESKY（基于CHOLESKY分解的方法），  DECOMP_LU（基于LU分解的方法），  DECOMP_EIG（基于特征值分解的方法）， DECOMP_SVD（基于奇异值分解的方法）。其中，前三种方法要求输入的矩阵必须为方阵，此时计算结果为矩阵的逆；最后一种方法为对非方阵的伪逆计算，对矩阵的形状没有要求。函数接口的默认参数为DECOMP_LU方法（应该是效率较高的一种方法）。</p>
<p><strong>4、实现代码</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line"></div><div class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt;&gt; vec&#123; &#123; <span class="number">0.68f</span>, <span class="number">0.597f</span>, <span class="number">-0.211</span>f &#125;,</div><div class="line">						&#123; <span class="number">0.823f</span>, <span class="number">0.566f</span>, <span class="number">-0.605</span>f &#125; &#125;;</div><div class="line">	<span class="keyword">const</span> <span class="keyword">int</span> rows&#123; <span class="number">2</span> &#125;, cols&#123; <span class="number">3</span> &#125;;</div><div class="line"></div><div class="line">	<span class="built_in">printf</span>(<span class="string">"source matrix:\n"</span>);</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vec.size(); i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; vec[i].size(); j++)</div><div class="line">			<span class="built_in">cout</span> &lt;&lt; vec[i][j] &lt;&lt; <span class="string">'\t'</span>;</div><div class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"\nopencv implement pseudoinverse:\n"</span>);</div><div class="line">	<span class="function">Mat <span class="title">mat</span><span class="params">(rows, cols, CV_32FC1)</span></span>;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; rows; ++y) &#123;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; cols; ++x) &#123;</div><div class="line">			mat.at&lt;<span class="keyword">float</span>&gt;(y, x) = vec[y][x];</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	Mat pinv2;</div><div class="line">	invert(mat, pinv2, cv::DECOMP_SVD);</div><div class="line">	</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; pinv2.rows; ++y)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; pinv2.cols; ++x)</div><div class="line">			<span class="built_in">cout</span> &lt;&lt; pinv2.at&lt;<span class="keyword">float</span>&gt;(y, x) &lt;&lt; <span class="string">'\t'</span>;</div><div class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	system(<span class="string">"pause"</span>);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/07/矩阵伪逆的opencv实现/" data-id="ckb5166bd000rlsvwpzzouap3" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-分水岭算法及其实现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/07/分水岭算法及其实现/" class="article-date">
  <time datetime="2020-06-07T11:15:32.000Z" itemprop="datePublished">2020-06-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/07/分水岭算法及其实现/">分水岭算法及其实现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>１ - 算法描述<br>1.1 分水岭算法的原理<br>　　分水岭的概念是以三维方式来形象化一幅图像为基础的：两个空间坐标再加上强度。在这种“地形学”解释中，考虑三种类型的点：（a）局部最小值点，该点对应一个盆地的最低点，当我们在盆地里滴一滴水的时候，由于重力作用，水最终会汇聚到该点。注意：可能存在一个最小值面，该平面内的都是最小值点。（b）盆地的其它位置点，该位置滴的水滴会汇聚到局部最小点。（c）盆地的边缘点，是该盆地和其它盆地交接点，在该点滴一滴水，会等概率的流向任何一个盆地。对于一个特定的区域最小值，满足条件（b）的点的集合称为该最小值的汇水盆地或分水岭。满足条件（c）的点形成地面的锋线，称为分割线或分水线。</p>
<center><img src="https://img-blog.csdnimg.cn/20190813183020645.png"></center><br><center>图1 分水岭算法中三种类型的点</center>

<p>&emsp;&emsp;基于这些概念的分割算法的主要目标是找出分水线。假设在每个区域的最小值上打一个洞，并且让水通过洞以均匀的速率上升，从低到高淹没整个地形。当不同汇水盆地中上升的水聚集时，修建一个水坝来阻止这种聚合。水将达到在水线上只能见到各个水坝的顶部的程度。这些大坝的边界对应于分水岭的分割线。因此，他们是由分水岭算法提取出来的边界。</p>
<p>１.2 水坝构建<br>　　在实际操作中，水位的上升常利用灰度0-255的分层处理来实现，当处理到第N层时，灰度小于N的像素就会被淹没。对于大多数情况，聚水盆的生长速度是不定的，也许在第N-1次处理时，两个聚水盆之间还有相当的距离，而在第N次处理中他们就已经相互连通了，这为堤坝的建立带来了一定的难度。</p>
<center><img src="https://img-blog.csdnimg.cn/20190813184430908.png"></center><br><center>图2 水坝构造示意图</center>

<p>&emsp;&emsp;图2中a显示了两个相邻的聚水盆，其中颜色越深的区域海拔越低，当水位逐渐上升到第N-1阶段时，黑色区域首先被淹没，如图2中b所示，这时图中存在两个彼此分开的水域，他们之间还有相当一段距离。然而当水面继续上升至第N阶段时，图中的水域已经连通，如图2中c所示。<br>&emsp;&emsp;为了在水域之间适当的位置构建堤坝防止水域的连通，可以借助图像形态学处理中的膨胀方法。由于已知两个水域会在第N-1阶段至第N阶段间连通，回到第N-1阶段的图像如图2中b所示，尝试对图中不同水域分别进行膨胀操作，并在膨胀中寻找两个区域的交点。如图2中d所示为两个水域分别进行一次膨胀操作的结果，从结果中可以看出两个区域仍然没有交点，因此还不能形成堤坝。继续对两个水域进行膨胀操作，在对右边区域的膨胀操作中，两个区域出现了交点，标记这些交点并在交点处修建堤坝，如图2中e所示，其中堤坝位置用交叉图案表示。继续进行膨胀操作，并不断标记新的交点，最终就能够得到完整的水坝轮廓。值得注意的是，在算法实现中，应对每次膨胀结果与第N阶段的淹没区域进行比较，保证堤坝位置在第N阶段的淹没区域之内，算法一直进行直到经过膨胀的水域完全覆盖第N阶段中淹没区域为止。通过以上步骤就能够获得较为准确的堤坝位置，如图2中f所示。<br>　　由于实际中处理的图像往往比较复杂，图中灰度极小值点较多，这就导致聚水盆数目过多，从而造成图像的过度分割，比如下面的图3，这样的分割效果是毫无用处的。解决图像的过度分割问题最直接的方法就是进行区域的合并，如果在分水岭算法中定义聚水盆的最小深度，就能比较好地解决过度分割的问题。</p>
<center><img src="https://img-blog.csdnimg.cn/20190813185335580.png"><img src="https://img-blog.csdnimg.cn/20190813185357370.png"></center><br><center>图3   过度分割的结果</center>

<p>&emsp;&emsp;聚水盆的深度可以定义为盆地中海拔最低点与当前水面高度的差值，在计算时可以用当前已淹没的灰度值减去区域的灰度最小值来得到。当水位上升造成两个不同的水域连接时，判断两个水域所在聚水盆的深度是否都大于定义的最小深度，若是则在两个区域间构建堤坝，否则对两个水域进行合并。运用这样的方法，就可以通过改变最小深度的值来控制图像分割的程度，从而获得图像最有效的分割结果。</p>
<p>２ - 分水岭算法的OpenCv实现<br>　　函数watershed实现的分水岭算法是基于标记的分割算法中的一种。在把图像传给函数之前，需要大致勾画标记出图像中的期望进行分割的区域，他们被标记为正指数。所以，每一个区域都会被标记为像素值1、2、3等，表示成为一个或者多个连接组件。这些标记的值可以使用findContours()函数和drawContours()函数由二进制的掩码检测出来。不难理解，这些标记就是即将绘制出来的分割区域的“种子”，而没有标记清楚的区域，被置为0。在函数输出中，每一个标记中的像素被设置为“种子”的值，而区域间的值被设置为-1。<br>　　C++: void watershed(InputArray image, InputOutputArray markers)<br>　　第一个参数，InputArray类型的src，输入图像，即原图像，填Mat类的对象即可，且需为8位三通道的彩色图像。<br>　　第二个参数，InputOutputArray类型的markers，函数调用后的运算结果存在这里，输入/输出32位单通道图像的标记结果。即这个参数用于存放函数调用后的输出结果，需和原图像有一样的尺寸和类型。</p>
<center><img src="https://img-blog.csdnimg.cn/20190813185836933.png"></center><br><center>图4 原始图</center>

<p>&emsp;&emsp;编写程序，对图4进行基于分水岭算法的图像分割。</p>
<center><img src="https://img-blog.csdnimg.cn/20190813185955642.png"><img src="https://img-blog.csdnimg.cn/20190813190003615.png"></center><br><center>图5 期望分割的区域</center>

<p>&emsp;&emsp;直接使用图像处理工具箱的提供的现成函数进行分割往往很难达到预期效果，而预先勾画标记出图像中期望进行分割的区域，在应用分水岭算法就会取得较好的分割效果。如图5所示，其中左图显示了原始图中期望进行分割的各个部分，右图更清楚的显示了期望分割部分的空间位置。</p>
<center><img src="https://img-blog.csdnimg.cn/20190813190114471.png"><img src="https://img-blog.csdnimg.cn/20190813190120382.png"></center><br><center>图6 分割结果</center>

<p>&emsp;&emsp;图6显示了分割的结果。分割的各个部分使用随机的颜色进行表示；若存在没有标记清楚的区域，则将此区域用纯黑色表示；用于划分区域的线条，即被设置为“种子”的像素值，用纯白色表示。左图显示了原始图像的分割结果，右图显示了分割结果和原始图按等比例进行混合的效果。</p>
<p>3 - OpenCv代码</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div></pre></td><td class="code"><pre><div class="line">#include "opencv2/imgproc/imgproc.hpp"</div><div class="line">#include "opencv2/highgui/highgui.hpp"</div><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace cv;</div><div class="line">using namespace std;</div><div class="line"></div><div class="line">//-----------------------------------【宏定义部分】-------------------------------------------- </div><div class="line">//  描述：定义一些辅助宏 </div><div class="line">//------------------------------------------------------------------------------------------------ </div><div class="line">#define WINDOW_NAME1 "【程序窗口1】"        //为窗口标题定义的宏 </div><div class="line">#define WINDOW_NAME2 "【分水岭算法效果图】"        //为窗口标题定义的宏</div><div class="line"></div><div class="line">//-----------------------------------【全局函变量声明部分】--------------------------------------</div><div class="line">//		描述：全局变量的声明</div><div class="line">//-----------------------------------------------------------------------------------------------</div><div class="line">Mat g_maskImage, g_srcImage;</div><div class="line">Point prevPt(-1, -1);</div><div class="line"></div><div class="line">static void on_Mouse(int event, int x, int y, int flags, void*);</div><div class="line"></div><div class="line"></div><div class="line">int main(int argc, char** argv)</div><div class="line">&#123;</div><div class="line">	//【0】改变console字体颜色</div><div class="line">	system("color 6F");</div><div class="line"></div><div class="line"></div><div class="line">	//【1】载入原图并显示，初始化掩膜和灰度图</div><div class="line">	g_srcImage = imread("1.jpg", 1);</div><div class="line">	imshow(WINDOW_NAME1, g_srcImage);</div><div class="line">	Mat srcImage, grayImage;</div><div class="line">	g_srcImage.copyTo(srcImage);</div><div class="line">	cvtColor(g_srcImage, g_maskImage, COLOR_BGR2GRAY);</div><div class="line">	cvtColor(g_maskImage, grayImage, COLOR_GRAY2BGR);</div><div class="line">	g_maskImage = Scalar::all(0);</div><div class="line"></div><div class="line">	//【2】设置鼠标回调函数</div><div class="line">	setMouseCallback(WINDOW_NAME1, on_Mouse, 0);</div><div class="line"></div><div class="line">	//【3】轮询按键，进行处理</div><div class="line">	while (1)</div><div class="line">	&#123;</div><div class="line">		//获取键值</div><div class="line">		int c = waitKey(0);</div><div class="line"></div><div class="line">		//若按键键值为ESC时，退出</div><div class="line">		if ((char)c == 27)</div><div class="line">			break;</div><div class="line"></div><div class="line">		//按键键值为2时，恢复源图</div><div class="line">		if ((char)c == '2')</div><div class="line">		&#123;</div><div class="line">			g_maskImage = Scalar::all(0);</div><div class="line">			srcImage.copyTo(g_srcImage);</div><div class="line">			imshow("image", g_srcImage);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		//若检测到按键值为1或者空格，则进行处理</div><div class="line">		if ((char)c == '1' || (char)c == ' ')</div><div class="line">		&#123;</div><div class="line">			//定义一些参数</div><div class="line">			int i, j, compCount = 0;</div><div class="line">			vector&lt;vector&lt;Point&gt; &gt; contours;</div><div class="line">			vector&lt;Vec4i&gt; hierarchy;</div><div class="line"></div><div class="line">			//寻找轮廓</div><div class="line">			findContours(g_maskImage, contours, hierarchy, CV_RETR_CCOMP, CV_CHAIN_APPROX_SIMPLE);</div><div class="line"></div><div class="line">			//轮廓为空时的处理</div><div class="line">			if (contours.empty())</div><div class="line">				continue;</div><div class="line"></div><div class="line">			//拷贝掩膜</div><div class="line">			Mat maskImage(g_maskImage.size(), CV_32S);</div><div class="line">			maskImage = Scalar::all(0);</div><div class="line"></div><div class="line">			//循环绘制出轮廓    //感觉这里绘制轮廓不重要，重要的是几个 因为后面又覆盖了maskImage watershed( srcImage, maskImage );</div><div class="line">			for (int index = 0; index &gt;= 0; index = hierarchy[index][0], compCount++)</div><div class="line">				drawContours(maskImage, contours, index, Scalar::all(compCount + 1), -1, 8, hierarchy, INT_MAX);</div><div class="line"></div><div class="line">			//compCount为零时的处理</div><div class="line">			if (compCount == 0)</div><div class="line">				continue;</div><div class="line"></div><div class="line">			//生成随机颜色</div><div class="line">			vector&lt;Vec3b&gt; colorTab;</div><div class="line">			for (i = 0; i &lt; compCount; i++)</div><div class="line">			&#123;</div><div class="line">				int b = theRNG().uniform(0, 255);</div><div class="line">				int g = theRNG().uniform(0, 255);</div><div class="line">				int r = theRNG().uniform(0, 255);</div><div class="line"></div><div class="line">				colorTab.push_back(Vec3b((uchar)b, (uchar)g, (uchar)r));</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			//计算处理时间并输出到窗口中</div><div class="line">			double dTime = (double)getTickCount();</div><div class="line">			watershed(srcImage, maskImage);</div><div class="line">			dTime = (double)getTickCount() - dTime;</div><div class="line">			printf("\t处理时间 = %gms\n", dTime*1000. / getTickFrequency());</div><div class="line"></div><div class="line">			//双层循环，将分水岭图像遍历存入watershedImage中</div><div class="line">			Mat watershedImage(maskImage.size(), CV_8UC3);</div><div class="line">			for (i = 0; i &lt; maskImage.rows; i++)</div><div class="line">				for (j = 0; j &lt; maskImage.cols; j++)</div><div class="line">				&#123;</div><div class="line">					int index = maskImage.at&lt;int&gt;(i, j);           //不同的index用不同的index颜色</div><div class="line">					if (index == -1)</div><div class="line">						watershedImage.at&lt;Vec3b&gt;(i, j) = Vec3b(255, 255, 255);</div><div class="line">					else if (index &lt;= 0 || index &gt; compCount)</div><div class="line">						watershedImage.at&lt;Vec3b&gt;(i, j) = Vec3b(0, 0, 0);</div><div class="line">					else</div><div class="line">						watershedImage.at&lt;Vec3b&gt;(i, j) = colorTab[index - 1];</div><div class="line">				&#125;</div><div class="line"></div><div class="line">			//混合灰度图和分水岭效果图并显示最终的窗口</div><div class="line">			watershedImage = watershedImage * 0.5 + grayImage * 0.5;</div><div class="line">			imshow(WINDOW_NAME2, watershedImage);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">static void on_Mouse(int event, int x, int y, int flags, void*)</div><div class="line">&#123;</div><div class="line">	//处理鼠标不在窗口中的情况</div><div class="line">	if (x &lt; 0 || x &gt;= g_srcImage.cols || y &lt; 0 || y &gt;= g_srcImage.rows)</div><div class="line">		return;</div><div class="line"></div><div class="line">	//处理鼠标左键相关消息</div><div class="line">	if (event == CV_EVENT_LBUTTONUP || !(flags &amp; CV_EVENT_FLAG_LBUTTON))</div><div class="line">		prevPt = Point(-1, -1);</div><div class="line">	else if (event == CV_EVENT_LBUTTONDOWN)</div><div class="line">		prevPt = Point(x, y);</div><div class="line"></div><div class="line">	//鼠标左键按下并移动，绘制出白色线条</div><div class="line">	else if (event == CV_EVENT_MOUSEMOVE &amp;&amp; (flags &amp; CV_EVENT_FLAG_LBUTTON))</div><div class="line">	&#123;</div><div class="line">		Point pt(x, y);</div><div class="line">		if (prevPt.x &lt; 0)</div><div class="line">			prevPt = pt;</div><div class="line">		line(g_maskImage, prevPt, pt, Scalar::all(255), 5, 8, 0);</div><div class="line">		line(g_srcImage, prevPt, pt, Scalar::all(0), 5, 8, 0);</div><div class="line">		prevPt = pt;</div><div class="line">		imshow(WINDOW_NAME1, g_srcImage);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/07/分水岭算法及其实现/" data-id="ckb5166bd000qlsvwko4rpuxu" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Canny算子c++实现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/07/Canny算子c++实现/" class="article-date">
  <time datetime="2020-06-07T11:14:58.000Z" itemprop="datePublished">2020-06-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/07/Canny算子c++实现/">Canny算子c++实现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>实现一个canny算子，opencv版本为3.4.5</p>
<p><img src="https://img-blog.csdnimg.cn/20190528220935410.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MjMxNzEz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div><div class="line">351</div><div class="line">352</div><div class="line">353</div><div class="line">354</div><div class="line">355</div><div class="line">356</div><div class="line">357</div><div class="line">358</div><div class="line">359</div><div class="line">360</div><div class="line">361</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/opencv.hpp"</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">生成高斯卷积核 kernel</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Gaussian_kernel</span><span class="params">(<span class="keyword">int</span> kernel_size, <span class="keyword">int</span> sigma, Mat &amp;kernel)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="number">3.1415926</span>;</div><div class="line">	<span class="keyword">int</span> m = kernel_size / <span class="number">2</span>;</div><div class="line"></div><div class="line">	kernel = Mat(kernel_size, kernel_size, CV_32FC1);</div><div class="line">	<span class="keyword">float</span> s = <span class="number">2</span> * sigma * sigma;</div><div class="line">	<span class="comment">//笔记： 注意二维高斯函数下面就是2*pi*sigma^2，没有根号</span></div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; kernel_size; i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; kernel_size; j++)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">int</span> x = i - m;</div><div class="line">			<span class="keyword">int</span> y = j - m;</div><div class="line"></div><div class="line">			kernel.at&lt;<span class="keyword">float</span>&gt;(i, j) = <span class="built_in">exp</span>(-(x * x + y * y) / s) / (PI * s);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">计算梯度值和方向</div><div class="line">imageSource 原始灰度图</div><div class="line">imageX X方向梯度图像</div><div class="line">imageY Y方向梯度图像</div><div class="line">gradXY 该点的梯度幅值</div><div class="line">theta 梯度方向角度 theta=arctan(imageY/imageX)</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">GradDirection</span><span class="params">(<span class="keyword">const</span> Mat imageSource, Mat &amp;imageX, Mat &amp;imageY, Mat &amp;gradXY, Mat &amp;theta)</span></span></div><div class="line">&#123;</div><div class="line">	</div><div class="line">	imageX = Mat::zeros(imageSource.size(), CV_32SC1);</div><div class="line">	imageY = Mat::zeros(imageSource.size(), CV_32SC1);</div><div class="line">	gradXY = Mat::zeros(imageSource.size(), CV_32SC1);</div><div class="line">	theta = Mat::zeros(imageSource.size(), CV_32SC1);</div><div class="line"></div><div class="line">	<span class="keyword">int</span> rows = imageSource.rows;</div><div class="line">	<span class="keyword">int</span> cols = imageSource.cols;</div><div class="line"></div><div class="line">	<span class="comment">/*</span></div><div class="line">	Mat.step参数指图像的一行实际占用的内存长度，以字节为基本单位，</div><div class="line">	因为opencv中的图像会对每行的长度自动补齐（8的倍数），</div><div class="line">	编程时尽量使用指针，指针读写像素是速度最快的，使用at函数最慢。</div><div class="line">	*/</div><div class="line">	<span class="keyword">int</span> stepXY = imageX.step;</div><div class="line">	<span class="keyword">int</span> step = imageSource.step;</div><div class="line"></div><div class="line">	<span class="comment">/*</span></div><div class="line">	Mat::data的默认类型为uchar*，但很多时候需要处理其它类型，如float、int，</div><div class="line">	此时需要将data强制类型转换，如：</div><div class="line">	Mat src(1000,1000,CV_32F);</div><div class="line">	float* myptr = (float*)src.data;</div><div class="line">	无论Mat的type是何种类型，Mat::data均为uchar*</div><div class="line">	*/</div><div class="line">	uchar *PX = imageX.data;</div><div class="line">	uchar *PY = imageY.data;</div><div class="line">	uchar *P = imageSource.data;</div><div class="line">	uchar *XY = gradXY.data;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; rows - <span class="number">1</span>; i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; cols - <span class="number">1</span>; j++)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">int</span> a00 = P[(i - <span class="number">1</span>)*step + j - <span class="number">1</span>];</div><div class="line">			<span class="keyword">int</span> a01 = P[(i - <span class="number">1</span>)*step + j];</div><div class="line">			<span class="keyword">int</span> a02 = P[(i - <span class="number">1</span>)*step + j + <span class="number">1</span>];</div><div class="line"></div><div class="line">			<span class="keyword">int</span> a10 = P[i*step + j - <span class="number">1</span>];</div><div class="line">			<span class="keyword">int</span> a11 = P[i*step + j];</div><div class="line">			<span class="keyword">int</span> a12 = P[i*step + j + <span class="number">1</span>];</div><div class="line"></div><div class="line">			<span class="keyword">int</span> a20 = P[(i + <span class="number">1</span>)*step + j - <span class="number">1</span>];</div><div class="line">			<span class="keyword">int</span> a21 = P[(i + <span class="number">1</span>)*step + j];</div><div class="line">			<span class="keyword">int</span> a22 = P[(i + <span class="number">1</span>)*step + j + <span class="number">1</span>];</div><div class="line"></div><div class="line">			<span class="keyword">double</span> gradX = <span class="keyword">double</span>(a02 + <span class="number">2</span> * a12 + a22 - a00 - <span class="number">2</span> * a10 - a20);</div><div class="line">			<span class="keyword">double</span> gradY = <span class="keyword">double</span>(a00 + <span class="number">2</span> * a01 + a02 - a20 - <span class="number">2</span> * a21 - a22);</div><div class="line"></div><div class="line">			<span class="comment">//遍历是从i,j=1开始到rows,cols-2的，图像像素都初始化为0，</span></div><div class="line">			<span class="comment">//所以最外边的一圈像素为0是黑的</span></div><div class="line">			<span class="comment">//PX[i*stepXY + j*(stepXY / step)] = abs(gradX);</span></div><div class="line">			<span class="comment">//PY[i*stepXY + j*(stepXY / step)] = abs(gradY);</span></div><div class="line">			imageX.at&lt;<span class="keyword">int</span>&gt;(i, j) = <span class="built_in">abs</span>(gradX);</div><div class="line">			imageY.at&lt;<span class="keyword">int</span>&gt;(i, j) = <span class="built_in">abs</span>(gradY);</div><div class="line">			<span class="keyword">if</span> (gradX == <span class="number">0</span>)</div><div class="line">			&#123;</div><div class="line">				gradX = <span class="number">0.000000000001</span>;</div><div class="line">			&#125;</div><div class="line">			<span class="comment">//弧度数改为角度数,除以pi乘以180</span></div><div class="line">			theta.at&lt;<span class="keyword">int</span>&gt;(i, j) = <span class="built_in">atan</span>(gradY / gradX) * <span class="number">57.3</span>;</div><div class="line">			theta.at&lt;<span class="keyword">int</span>&gt;(i, j) = (theta.at&lt;<span class="keyword">int</span>&gt;(i, j) + <span class="number">360</span>) % <span class="number">360</span>;</div><div class="line">			gradXY.at&lt;<span class="keyword">int</span>&gt;(i, j) = <span class="built_in">sqrt</span>(gradX*gradX + gradY * gradY);</div><div class="line">			<span class="comment">//XY[i * stepXY + j * (stepXY / step)] = sqrt(gradX * gradX + gradY * gradY);</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">/*</span></div><div class="line">	在经过处理后，需要用convertScaleAbs()函数将其转回原来的uint8形式，</div><div class="line">	否则将无法显示图像，而只是一副灰色的窗口。 </div><div class="line">	函数原型为</div><div class="line">	void convertScaleAbs(InputArray src, OutputArray dst,</div><div class="line">                                  double alpha = 1, double beta = 0);</div><div class="line">	其中可选参数alpha是伸缩系数，beta是加到结果上的一个值，结果返回uint8类型的图片</div><div class="line">	功能：实现将原图片转换为uint8类型</div><div class="line">	*/</div><div class="line">	convertScaleAbs(imageX, imageX);</div><div class="line">	convertScaleAbs(imageY, imageY);</div><div class="line">	convertScaleAbs(gradXY, gradXY);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">局部非极大值抑制</div><div class="line">沿着该点梯度方向，比较前后两个点的幅值大小，若该点大于前后两点，则保留，</div><div class="line">若该点小于前后两点任意一点，则置为0；</div><div class="line">imageInput 输入得到梯度图像</div><div class="line">imageOutput 输出的非极大值抑制图像</div><div class="line">theta 每个像素点的梯度方向角度</div><div class="line">imageX X方向梯度</div><div class="line">imageY Y方向梯度</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">NonLocalMaxValue</span><span class="params">(<span class="keyword">const</span> Mat imageInput, Mat &amp;imageOutput, <span class="keyword">const</span> Mat &amp;theta, <span class="keyword">const</span> Mat &amp;imageX, <span class="keyword">const</span> Mat &amp;imageY)</span></span></div><div class="line">&#123;</div><div class="line">	imageOutput = imageInput.clone();</div><div class="line"></div><div class="line"></div><div class="line">	<span class="keyword">int</span> cols = imageInput.cols;</div><div class="line">	<span class="keyword">int</span> rows = imageInput.rows;</div><div class="line"></div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; rows - <span class="number">1</span>; i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; cols - <span class="number">1</span>; j++)</div><div class="line">		&#123;</div><div class="line">			<span class="comment">//执行continue时，会执行本次迭代的剩余部分，并开始下一次迭代</span></div><div class="line">			<span class="comment">//执行break时，会执行包含它的循环，并执行下一阶段</span></div><div class="line">			<span class="keyword">if</span> (<span class="number">0</span> == imageInput.at&lt;uchar&gt;(i, j))<span class="keyword">continue</span>;</div><div class="line"></div><div class="line">			<span class="keyword">int</span> g00 = imageInput.at&lt;uchar&gt;(i - <span class="number">1</span>, j - <span class="number">1</span>);</div><div class="line">			<span class="keyword">int</span> g01 = imageInput.at&lt;uchar&gt;(i - <span class="number">1</span>, j);</div><div class="line">			<span class="keyword">int</span> g02 = imageInput.at&lt;uchar&gt;(i - <span class="number">1</span>, j + <span class="number">1</span>);</div><div class="line"></div><div class="line">			<span class="keyword">int</span> g10 = imageInput.at&lt;uchar&gt;(i, j - <span class="number">1</span>);</div><div class="line">			<span class="keyword">int</span> g11 = imageInput.at&lt;uchar&gt;(i, j);</div><div class="line">			<span class="keyword">int</span> g12 = imageInput.at&lt;uchar&gt;(i, j + <span class="number">1</span>);</div><div class="line"></div><div class="line">			<span class="keyword">int</span> g20 = imageInput.at&lt;uchar&gt;(i + <span class="number">1</span>, j - <span class="number">1</span>);</div><div class="line">			<span class="keyword">int</span> g21 = imageInput.at&lt;uchar&gt;(i + <span class="number">1</span>, j);</div><div class="line">			<span class="keyword">int</span> g22 = imageInput.at&lt;uchar&gt;(i + <span class="number">1</span>, j + <span class="number">1</span>);</div><div class="line"></div><div class="line">			<span class="keyword">int</span> direction = theta.at&lt;<span class="keyword">int</span>&gt;(i, j); <span class="comment">//该点梯度的角度值</span></div><div class="line">			<span class="keyword">int</span> g1 = <span class="number">0</span>;</div><div class="line">			<span class="keyword">int</span> g2 = <span class="number">0</span>;</div><div class="line">			<span class="keyword">int</span> g3 = <span class="number">0</span>;</div><div class="line">			<span class="keyword">int</span> g4 = <span class="number">0</span>;</div><div class="line">			<span class="keyword">double</span> tmp1 = <span class="number">0.0</span>; <span class="comment">//保存亚像素点插值得到的灰度数</span></div><div class="line">			<span class="keyword">double</span> tmp2 = <span class="number">0.0</span>;</div><div class="line">			<span class="comment">//在C中，有abs(),labs(),fabs()分别计算int ,long ,double 类型的绝对值；</span></div><div class="line">			<span class="comment">//而在C++中，abs()已被重载，可适用于各种类型</span></div><div class="line">			<span class="keyword">double</span> weight = <span class="built_in">fabs</span>((<span class="keyword">double</span>)imageY.at&lt;uchar&gt;(i, j) / (<span class="keyword">double</span>)imageX.at&lt;uchar&gt;(i, j));</div><div class="line"></div><div class="line">			<span class="comment">//去掉也可以，如果weight==0，那direction==0或180就不用差值，直接用原来的值</span></div><div class="line">			<span class="keyword">if</span> (weight == <span class="number">0</span>)</div><div class="line">				weight = <span class="number">0.0000001</span>;</div><div class="line">			<span class="comment">/*</span></div><div class="line">			关于这些公式的含义</div><div class="line">			https://www.cnblogs.com/love6tao/p/5152020.html 有解释</div><div class="line">			形如g10 * (1 - weight) + g20 * (weight)都是用两边的像素计算得到的亚像素</div><div class="line">			不过他w和1-w应该写反了</div><div class="line">			*/</div><div class="line">			<span class="keyword">if</span> (weight &gt; <span class="number">1</span>)</div><div class="line">			&#123;</div><div class="line">				weight = <span class="number">1</span> / weight;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> ((<span class="number">0</span> &lt;= direction &amp;&amp; direction &lt; <span class="number">45</span>) || <span class="number">180</span> &lt;= direction &amp;&amp; direction &lt; <span class="number">225</span>)</div><div class="line">			&#123;</div><div class="line">				tmp1 = g10 * (<span class="number">1</span> - weight) + g20 * (weight);</div><div class="line">				tmp2 = g02 * (weight)+g12 * (<span class="number">1</span> - weight);</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> ((<span class="number">45</span> &lt;= direction &amp;&amp; direction &lt; <span class="number">90</span>) || <span class="number">225</span> &lt;= direction &amp;&amp; direction &lt; <span class="number">270</span>)</div><div class="line">			&#123;</div><div class="line">				tmp1 = g01 * (<span class="number">1</span> - weight) + g02 * (weight);</div><div class="line">				tmp2 = g20 * (weight)+g21 * (<span class="number">1</span> - weight);</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> ((<span class="number">90</span> &lt;= direction &amp;&amp; direction &lt; <span class="number">135</span>) || <span class="number">270</span> &lt;= direction &amp;&amp; direction &lt; <span class="number">315</span>)</div><div class="line">			&#123;</div><div class="line">				tmp1 = g00 * (weight)+g01 * (<span class="number">1</span> - weight);</div><div class="line">				tmp2 = g21 * (<span class="number">1</span> - weight) + g22 * (weight);</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> ((<span class="number">135</span> &lt;= direction &amp;&amp; direction &lt; <span class="number">180</span>) || <span class="number">315</span> &lt;= direction &amp;&amp; direction &lt; <span class="number">360</span>)</div><div class="line">			&#123;</div><div class="line">				tmp1 = g00 * (weight)+g10 * (<span class="number">1</span> - weight);</div><div class="line">				tmp2 = g12 * (<span class="number">1</span> - weight) + g22 * (weight);</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			<span class="keyword">if</span> (imageInput.at&lt;uchar&gt;(i, j) &lt; tmp1 || imageInput.at&lt;uchar&gt;(i, j) &lt; tmp2)</div><div class="line">			&#123;</div><div class="line">				imageOutput.at&lt;uchar&gt;(i, j) = <span class="number">0</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">双阈值的机理是：</div><div class="line">指定一个低阈值A，一个高阈值B，选取占直方图总数70%为B，且B为1.5到2倍大小的A；</div><div class="line">灰度值小于A的，置为0,灰度值大于B的，置为255；</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoubleThreshold</span><span class="params">(Mat &amp;imageInput, <span class="keyword">const</span> <span class="keyword">double</span> lowThreshold, <span class="keyword">const</span> <span class="keyword">double</span> highThreshold)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> cols = imageInput.cols;</div><div class="line">	<span class="keyword">int</span> rows = imageInput.rows;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">double</span> temp = imageInput.at&lt;uchar&gt;(i, j);</div><div class="line">			temp = temp &gt; highThreshold ? (<span class="number">255</span>) : (temp);</div><div class="line">			temp = temp &lt; lowThreshold ? (<span class="number">0</span>) : (temp);</div><div class="line">			imageInput.at&lt;uchar&gt;(i, j) = temp;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line">连接处理:</div><div class="line">灰度值介于A和B之间的，考察该像素点临近的8像素是否有灰度值为255的，</div><div class="line">若没有255的，表示这是一个孤立的局部极大值点，予以排除，置为0；</div><div class="line">若有255的，表示这是一个跟其他边缘有“接壤”的可造之材，置为255，</div><div class="line">之后重复执行该步骤，直到考察完最后一个像素点。</div><div class="line"></div><div class="line">其中的邻域跟踪算法，从值为255的像素点出发找到周围满足要求的点，把满足要求的点设置为255，</div><div class="line">然后修改i,j的坐标值，i,j值进行回退，在改变后的i,j基础上继续寻找255周围满足要求的点。</div><div class="line">当所有连接255的点修改完后，再把所有上面所说的局部极大值点置为0；（算法可以继续优化）。</div><div class="line"></div><div class="line">参数1，imageInput：输入和输出的梯度图像</div><div class="line">参数2，lowTh:低阈值</div><div class="line">参数3，highTh:高阈值</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoubleThresholdLink</span><span class="params">(Mat &amp;imageInput, <span class="keyword">double</span> lowTh, <span class="keyword">double</span> highTh)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> cols = imageInput.cols;</div><div class="line">	<span class="keyword">int</span> rows = imageInput.rows;</div><div class="line"></div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; rows - <span class="number">1</span>; i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; cols - <span class="number">1</span>; j++)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">double</span> pix = imageInput.at&lt;uchar&gt;(i, j);</div><div class="line">			<span class="keyword">if</span> (pix != <span class="number">255</span>)<span class="keyword">continue</span>;</div><div class="line">			<span class="keyword">bool</span> change = <span class="literal">false</span>;</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">-1</span>; k &lt;= <span class="number">1</span>; k++)</div><div class="line">			&#123;</div><div class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">-1</span>; u &lt;= <span class="number">1</span>; u++)</div><div class="line">				&#123;</div><div class="line">					<span class="keyword">if</span> (k == <span class="number">0</span> &amp;&amp; u == <span class="number">0</span>)<span class="keyword">continue</span>;</div><div class="line">					<span class="keyword">double</span> temp = imageInput.at&lt;uchar&gt;(i + k, j + u);</div><div class="line">					<span class="keyword">if</span> (temp &gt;= lowTh &amp;&amp; temp &lt;= highTh)</div><div class="line">					&#123;</div><div class="line">						imageInput.at&lt;uchar&gt;(i + k, j + u) = <span class="number">255</span>;</div><div class="line">						change = <span class="literal">true</span>;</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="comment">//如果要连接像素值，则如果连接的是上边三个或者左边紧挨着的一个</span></div><div class="line">			<span class="comment">//可能会对之前的像素产生影响，即可能前面的邻接像素也要改变</span></div><div class="line">			<span class="comment">//这里采取的方法是不管要改变哪个像素，都将当前位置返回到左上角</span></div><div class="line">			<span class="comment">//最上面一条边和最左边一条边不能返回到左上角，就分别左移和上移一格</span></div><div class="line">			<span class="comment">//注意j马上还要+1，i不用+1</span></div><div class="line">			<span class="comment">//至于为什么是i&gt;1而j&gt;2，其实j&gt;1也可以，只是因为j是减2，而2-2=0，不过还要+1所以没问题</span></div><div class="line">			<span class="keyword">if</span> (change)</div><div class="line">			&#123;</div><div class="line">				<span class="keyword">if</span> (i &gt; <span class="number">1</span>)i--;</div><div class="line">				<span class="keyword">if</span> (j &gt; <span class="number">2</span>)j -= <span class="number">2</span>;</div><div class="line"></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">if</span> (imageInput.at&lt;uchar&gt;(i, j) != <span class="number">255</span>)</div><div class="line">			&#123;</div><div class="line">				imageInput.at&lt;uchar&gt;(i, j) = <span class="number">0</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="comment">//Mat image = imread("lena.png");</span></div><div class="line">	<span class="comment">//imshow("origin image", image);</span></div><div class="line"></div><div class="line">	<span class="comment">//转换为灰度图</span></div><div class="line">	<span class="comment">//Mat grayImage;</span></div><div class="line">	<span class="comment">//cvtColor(image, grayImage, CV_RGB2GRAY);</span></div><div class="line"></div><div class="line">	Mat grayImage = imread(<span class="string">"I.bmp"</span>, <span class="number">0</span>);</div><div class="line">	imshow(<span class="string">"gray image"</span>, grayImage);</div><div class="line"></div><div class="line">	<span class="comment">//高斯滤波</span></div><div class="line">	Mat gausKernel;</div><div class="line">	<span class="keyword">int</span> kernel_size = <span class="number">5</span>;</div><div class="line">	<span class="keyword">double</span> sigma = <span class="number">1</span>;</div><div class="line">	Gaussian_kernel(kernel_size, sigma, gausKernel);</div><div class="line">	Mat gausImage;</div><div class="line">	<span class="comment">//Convolves an image with kernel 即利用内核实现对图像的卷积运算</span></div><div class="line">	filter2D(grayImage, gausImage, grayImage.depth(), gausKernel);</div><div class="line">	imshow(<span class="string">"gaus image"</span>, gausImage);</div><div class="line">	imwrite(<span class="string">"高斯滤波后的图像.bmp"</span>, gausImage);</div><div class="line"></div><div class="line">	<span class="comment">//计算XY方向梯度</span></div><div class="line">	Mat imageX, imageY, imageXY;</div><div class="line">	<span class="comment">//theta为梯度方向，theta=arctan(imageY/imageX)</span></div><div class="line">	Mat theta;</div><div class="line">	GradDirection(gausImage, imageX, imageY, imageXY, theta);</div><div class="line">	imshow(<span class="string">"XY grad"</span>, imageXY);</div><div class="line">	imwrite(<span class="string">"梯度模值.bmp"</span>, imageXY);</div><div class="line"></div><div class="line">	<span class="comment">//对梯度幅值进行非极大值抑制</span></div><div class="line">	Mat localImage;</div><div class="line">	NonLocalMaxValue(imageXY, localImage, theta, imageX, imageY);</div><div class="line">	imshow(<span class="string">"Non local maxinum image"</span>, localImage);</div><div class="line">	imwrite(<span class="string">"非极大性值抑制.bmp"</span>, localImage);</div><div class="line"></div><div class="line">	<span class="comment">//双阈值算法检测和边缘连接</span></div><div class="line">	DoubleThreshold(localImage, <span class="number">60</span>, <span class="number">100</span>);</div><div class="line">	DoubleThresholdLink(localImage, <span class="number">60</span>, <span class="number">100</span>);</div><div class="line">	imshow(<span class="string">"canny image"</span>, localImage);</div><div class="line">	imwrite(<span class="string">"双阈值和边缘连接.bmp"</span>, localImage);</div><div class="line"></div><div class="line">	Mat temMat;</div><div class="line">	<span class="comment">/*</span></div><div class="line">	void Canny( InputArray image, OutputArray edges,</div><div class="line">                         double threshold1, double threshold2,</div><div class="line">                         int apertureSize = 3, bool L2gradient = false );</div><div class="line">	输入图像 输出图像 低阈值 高阈值 算子大小 是否采用更精确的方式计算图像梯度</div><div class="line">	void Canny( InputArray dx, InputArray dy,</div><div class="line">						 OutputArray edges,</div><div class="line">						 double threshold1, double threshold2,</div><div class="line">						 bool L2gradient = false );</div><div class="line">	输入图像x,y方向的导数 输出图像 低阈值 高阈值 算子大小 是否采用更精确的方式计算图像梯度</div><div class="line">	*/</div><div class="line">	Canny(grayImage, temMat, <span class="number">60</span>, <span class="number">100</span>);</div><div class="line">	imshow(<span class="string">"opencv canny image"</span>, temMat);</div><div class="line">	imwrite(<span class="string">"opencv自带的canny算法得到的效果图.bmp"</span>, temMat);</div><div class="line"></div><div class="line">	waitKey(<span class="number">0</span>);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/07/Canny算子c++实现/" data-id="ckb5166a20007lsvwga8fch7o" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-C++实现均值滤波器和中值滤波器" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/07/C++实现均值滤波器和中值滤波器/" class="article-date">
  <time datetime="2020-06-07T11:13:09.000Z" itemprop="datePublished">2020-06-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/07/C++实现均值滤波器和中值滤波器/">C++实现均值滤波器和中值滤波器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>C++实现均值滤波器和中值滤波器</p>
<p>代码实现均值滤波器和中值滤波器<br><img src="https://img-blog.csdnimg.cn/20190528214511207.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MjMxNzEz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>由于中值滤波器是非线性滤波，不是卷积，所以均值和中值滤波分开实现。opencv版本为3.4.5</p>
<p>my_convolution.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MY_CONVOLUTION</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_CONVOLUTION</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">class</span> My_Convolution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	My_Convolution();</div><div class="line">	~My_Convolution();</div><div class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">load_kernal</span><span class="params">(<span class="keyword">const</span> cv::Mat kernal)</span></span>;<span class="comment">//加载卷积核</span></div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">convolute</span><span class="params">(<span class="keyword">const</span> cv::Mat &amp;image, cv::Mat &amp;dst)</span></span>;<span class="comment">//卷积操作</span></div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">	<span class="keyword">bool</span> kernal_loaded;<span class="comment">//是否已经加载卷积核</span></div><div class="line">	cv::Mat curr_kernal;<span class="comment">//当前卷积核</span></div><div class="line">	<span class="keyword">int</span> bios_x, bios_y;<span class="comment">//记录偏移量</span></div><div class="line"></div><div class="line">	<span class="comment">//计算每一个像素的掩模乘积之和</span></div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">compute_sum_of_product</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> chan, cv::Mat &amp;complete_image, cv::Mat &amp; dst)</span></span>;</div><div class="line">	<span class="comment">//将原图像转换成边框补全的图像</span></div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">complete_image_transform</span><span class="params">(<span class="keyword">const</span> cv::Mat &amp;image, cv::Mat &amp;dst)</span></span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// MY_CONVOLUTION</span></span></div></pre></td></tr></table></figure>
<p>my_convolution.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"my_convolution.h"</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</div><div class="line"></div><div class="line">My_Convolution::My_Convolution() &#123;</div><div class="line">	kernal_loaded = <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line">My_Convolution::~My_Convolution() &#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">//加载卷积核</span></div><div class="line"><span class="keyword">bool</span> My_Convolution::load_kernal(<span class="keyword">const</span> Mat kernal) &#123;</div><div class="line">	<span class="keyword">if</span> (kernal.cols % <span class="number">2</span> == <span class="number">1</span> &amp;&amp; kernal.rows % <span class="number">2</span> == <span class="number">1</span>) &#123;</div><div class="line">		curr_kernal = kernal.clone();</div><div class="line">		bios_x = (kernal.cols - <span class="number">1</span>) / <span class="number">2</span>;</div><div class="line">		bios_y = (kernal.rows - <span class="number">1</span>) / <span class="number">2</span>;</div><div class="line">		kernal_loaded = <span class="literal">true</span>;</div><div class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> &#123;</div><div class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"The size of kernal is not suitable!"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//卷积操作</span></div><div class="line"><span class="keyword">void</span> My_Convolution::convolute(<span class="keyword">const</span> Mat &amp;image, Mat &amp;dst) &#123;</div><div class="line">	<span class="keyword">if</span> (!kernal_loaded) &#123;</div><div class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"kernal is empty!Please load the kernal first!"</span> &lt;&lt; <span class="built_in">endl</span>;<span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line">	Mat complete_image;</div><div class="line">	complete_image_transform(image, complete_image);</div><div class="line">	dst = Mat::zeros(image.rows, image.cols, image.type());</div><div class="line">	<span class="keyword">int</span> channels = image.channels();<span class="comment">//获取图像的通道数</span></div><div class="line">	<span class="keyword">if</span> (channels == <span class="number">3</span>) &#123;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> chan = <span class="number">0</span>;chan &lt; channels;chan++) &#123;</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; dst.rows;i++) &#123;</div><div class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; dst.cols;j++) &#123;</div><div class="line">					compute_sum_of_product(i, j, chan, complete_image, dst);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (channels == <span class="number">1</span>) &#123;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; dst.rows;i++) &#123;</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; dst.cols;j++) &#123;</div><div class="line">				compute_sum_of_product(i, j, <span class="number">0</span>, complete_image, dst);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//计算掩模乘积之和</span></div><div class="line"><span class="keyword">void</span> My_Convolution::compute_sum_of_product(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> chan, Mat &amp;complete_image, Mat &amp;dst) &#123;</div><div class="line">	<span class="keyword">if</span> (complete_image.channels() == <span class="number">3</span>) &#123;</div><div class="line">		<span class="keyword">float</span> sum = <span class="number">0</span>;</div><div class="line">		<span class="keyword">int</span> bios_rows = i;</div><div class="line">		<span class="keyword">int</span> bios_cols = j;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> curr_rows = <span class="number">0</span>;curr_rows &lt; curr_kernal.rows;curr_rows++) &#123;</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> curr_cols = <span class="number">0</span>;curr_cols &lt; curr_kernal.cols;curr_cols++) &#123;</div><div class="line">				<span class="keyword">float</span> a = curr_kernal.at&lt;<span class="keyword">float</span>&gt;(curr_rows, curr_cols)*complete_image.at&lt;Vec3b&gt;(curr_rows + bios_rows, curr_cols + bios_cols)[chan];</div><div class="line">				sum += a;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		dst.at&lt;Vec3b&gt;(i, j)[chan] = (<span class="keyword">int</span>)sum;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (complete_image.channels() == <span class="number">1</span>) &#123;</div><div class="line">			<span class="keyword">float</span> sum = <span class="number">0</span>;</div><div class="line">			<span class="keyword">int</span> bios_rows = i;</div><div class="line">			<span class="keyword">int</span> bios_cols = j;</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> curr_rows = <span class="number">0</span>;curr_rows &lt; curr_kernal.rows;curr_rows++) &#123;</div><div class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> curr_cols = <span class="number">0</span>;curr_cols &lt; curr_kernal.cols;curr_cols++) &#123;</div><div class="line">					<span class="keyword">float</span> a = curr_kernal.at&lt;<span class="keyword">float</span>&gt;(curr_rows, curr_cols)*complete_image.at&lt;uchar&gt;(curr_rows + bios_rows, curr_cols + bios_cols);</div><div class="line">					sum += a;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			dst.at&lt;uchar&gt;(i, j) = (<span class="keyword">int</span>)sum;</div><div class="line">		&#125;</div><div class="line">	<span class="keyword">else</span> &#123;</div><div class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"the type of image is not suitable!"</span> &lt;&lt; <span class="built_in">endl</span>;<span class="keyword">return</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//边框像素补全</span></div><div class="line"><span class="keyword">void</span> My_Convolution::complete_image_transform(<span class="keyword">const</span> Mat &amp;image, Mat &amp;dst) &#123;</div><div class="line">	<span class="keyword">if</span> (!kernal_loaded) &#123;</div><div class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"kernal is empty!"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//Mat的type（）成员函数生成CV_&lt;位数&gt;(S/U/F)C&lt;通道数&gt;</span></div><div class="line">	<span class="comment">//初始化一个补全图像的大小。</span></div><div class="line">	dst = Mat::zeros(<span class="number">2</span> * bios_y + image.rows, <span class="number">2</span> * bios_x + image.cols, image.type());</div><div class="line">	Rect real_roi_of_image = Rect(bios_x, bios_y, image.cols, image.rows);</div><div class="line">	Mat real_mat_of_image = dst(real_roi_of_image);</div><div class="line">	image.copyTo(real_mat_of_image);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>my_nedianfilter.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MY_MEDIANFILTER</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_MEDIANFILTER</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">MedianFilter</span><span class="params">(Mat&amp; src, Mat&amp; dst, <span class="keyword">int</span> win_size)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Complete_Image_Transform</span><span class="params">(Mat &amp;src, Mat &amp;comp, <span class="keyword">int</span> size)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Calc_Median</span><span class="params">(Mat&amp; comp, Mat&amp; dst, <span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">int</span> s)</span></span>;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<p>my_nedianfilter.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"my_medianfilter.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">MedianFilter</span><span class="params">(Mat&amp; src, Mat&amp; dst, <span class="keyword">int</span> win_size)</span> </span>&#123;</div><div class="line">	Mat comp = src.clone();</div><div class="line">	Complete_Image_Transform(src, comp, win_size);</div><div class="line"></div><div class="line">	<span class="keyword">int</span> rows = comp.rows, cols = comp.cols;</div><div class="line">	<span class="keyword">int</span> start = win_size / <span class="number">2</span>;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (comp.channels() &gt; <span class="number">1</span>)</div><div class="line">	&#123;</div><div class="line">		<span class="comment">//彩色图片通道分离</span></div><div class="line">		<span class="built_in">vector</span>&lt;Mat&gt; channels_c, channels_d;</div><div class="line">		split(comp, channels_c);</div><div class="line">		split(comp, channels_d);</div><div class="line">		<span class="comment">//滤波</span></div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</div><div class="line">			Calc_Median(channels_c[i], channels_d[i], rows, cols, start);</div><div class="line"></div><div class="line">		<span class="comment">//合并彩色通道</span></div><div class="line">		merge(channels_d, dst);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span></div><div class="line">		Calc_Median(comp, dst, rows, cols, start);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//边框像素补全</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Complete_Image_Transform</span><span class="params">(Mat &amp;src, Mat &amp;comp, <span class="keyword">int</span> size)</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="comment">//初始化一个补全图像的大小</span></div><div class="line">	comp = Mat::zeros(<span class="number">2</span> * (size / <span class="number">2</span>) + src.rows, <span class="number">2</span> * (size / <span class="number">2</span>) + src.cols, src.type());</div><div class="line">	Rect real_roi_of_image = Rect((size / <span class="number">2</span>), (size / <span class="number">2</span>), src.cols, src.rows);</div><div class="line">	Mat real_mat_of_image = comp(real_roi_of_image);</div><div class="line">	src.copyTo(real_mat_of_image);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Calc_Median</span><span class="params">(Mat&amp; comp, Mat&amp; dst, <span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">int</span> s)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> m = s; m &lt; r - s; m++) &#123;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> n = s; n &lt; c - s; n++) &#123;</div><div class="line">			<span class="built_in">vector</span>&lt;uchar&gt; model;</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = -s + m; i &lt;= s + m; i++) &#123;</div><div class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = -s + n; j &lt;= s + n; j++) &#123;</div><div class="line">					<span class="comment">//cout &lt;&lt; int(src.at&lt;uchar&gt;(i, j)) &lt;&lt; endl;</span></div><div class="line">					model.push_back(comp.at&lt;uchar&gt;(i, j));</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			sort(model.begin(), model.end());     <span class="comment">//采用快速排序进行</span></div><div class="line">			dst.at&lt;uchar&gt;(m - s, n - s) = model[(s * <span class="number">2</span> + <span class="number">1</span>) * (s * <span class="number">2</span> + <span class="number">1</span>) / <span class="number">2</span>];</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/07/C++实现均值滤波器和中值滤波器/" data-id="ckb51669m0003lsvw843hemw2" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-C++默认初始化和值初始化、 直接初始化和拷贝初始化" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/07/C++默认初始化和值初始化、 直接初始化和拷贝初始化/" class="article-date">
  <time datetime="2020-06-07T10:49:39.000Z" itemprop="datePublished">2020-06-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/07/C++默认初始化和值初始化、 直接初始化和拷贝初始化/">C++默认初始化和值初始化、 直接初始化和拷贝初始化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="默认初始化和值初始化一一对应"><a href="#默认初始化和值初始化一一对应" class="headerlink" title="默认初始化和值初始化一一对应"></a>默认初始化和值初始化一一对应</h1><p><strong>前提知识</strong><br>声明： 在环境/上下文中指定一个变量的名字。也就是说，声明仅仅是让编译器知道，而没有实际分配空间。</p>
<p>初始化：给一个声明后尚未初始化的变量一个有意义的初始值。</p>
<p>赋值 ： 销毁一个变量原来的值，并赋予一个新值。相当于改变了一个变量的状态。</p>
<h2 id="默认初始化："><a href="#默认初始化：" class="headerlink" title="默认初始化："></a>默认初始化：</h2><p>对象可能产生未定义的值（是否绝对尚待确定，例如类类型（定义了默认构造函数）的默认初始化是否属于值初始化等）。</p>
<h2 id="值初始化："><a href="#值初始化：" class="headerlink" title="值初始化："></a>值初始化：</h2><p>对象的值是确定（预设）的。</p>
<h2 id="值初始化出现场景："><a href="#值初始化出现场景：" class="headerlink" title="值初始化出现场景："></a>值初始化出现场景：</h2><p>1.数组初始化时初始值数量小于维度，剩下的元素会进行值初始化；<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123; <span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; &#125;</div></pre></td></tr></table></figure></p>
<p>2.当我们不使用初始值定义一个静态变量；<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//未经初始化的全局静态变量和局部静态变量都会被自动初始化为0</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> n1;		<span class="comment">//n1值初始化为0</span></div><div class="line">&#123; <span class="keyword">static</span> <span class="keyword">int</span> n2; &#125;	<span class="comment">//n2值初始化为0</span></div></pre></td></tr></table></figure></p>
<p>3.形如T()的表达式显示地请求值初始化；<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123; </div><div class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> *pia1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]();	<span class="comment">//动态分配10个值初始化为0的int</span></div><div class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> *pia2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];	<span class="comment">//动态分配10个未初始化的int</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>4.只提供vector对象容纳的元素数量而略去初始值，此时库会创建一个值初始化的元素初值(c++ primer p88)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec(<span class="number">10</span>);	<span class="comment">//10个元素都被初始化为0</span></div></pre></td></tr></table></figure></p>
<h2 id="默认初始化出现场景："><a href="#默认初始化出现场景：" class="headerlink" title="默认初始化出现场景："></a>默认初始化出现场景：</h2><p>1.块作用域内不使用任何初始值定义一个非静态变量；<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123; <span class="keyword">int</span> a; &#125;<span class="comment">//a的值是未定义的，但若在任何函数之外，会被初始化为0</span></div></pre></td></tr></table></figure></p>
<p>2.类通过默认构造函数来控制默认初始化过程，默认构造函数以如下规则初始化类的数据成员</p>
<ul>
<li>如果存在类内初始值，用它来初始化成员 </li>
<li>否则，默认初始化该成员</li>
</ul>
<h1 id="直接初始化和拷贝初始化一一对应"><a href="#直接初始化和拷贝初始化一一对应" class="headerlink" title="直接初始化和拷贝初始化一一对应"></a>直接初始化和拷贝初始化一一对应</h1><h2 id="直接初始化："><a href="#直接初始化：" class="headerlink" title="直接初始化："></a>直接初始化：</h2><p>直接调用与实参匹配的构造函数，形式如“T t(u)”。</p>
<h2 id="拷贝初始化："><a href="#拷贝初始化：" class="headerlink" title="拷贝初始化："></a>拷贝初始化：</h2><p>拷贝初始化首先使用指定构造函数创建一个临时对象，然后用拷贝构造函数将那个临时对象复制到正在创建的对象”，形式如“T t=u”。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/07/C++默认初始化和值初始化、 直接初始化和拷贝初始化/" data-id="ckb51669m0002lsvwm18kwu5u" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-分布式和集中式的版本控制的区别" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/07/分布式和集中式的版本控制的区别/" class="article-date">
  <time datetime="2020-06-07T10:21:13.000Z" itemprop="datePublished">2020-06-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/07/分布式和集中式的版本控制的区别/">分布式和集中式的版本控制的区别</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"><br>                    <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"><br>                        <div class="htmledit_views"></div></div></p>
<p><div class="toc" style="color:rgb(51,51,51);font-size:14px;border:1px solid rgb(238,238,238);vertical-align:baseline;width:300px;line-height:15px;font-family:Arial, sans-serif;background:rgb(249,249,249);"></div></p>
<p><ol class="dtree" style="border:0px;vertical-align:baseline;list-style:none;font-family:'PT Serif', Georgia, Times, 'Times New Roman', 'Heiti SC', 'Microsoft Yahei', '微软雅黑', '宋体', serif;background:transparent;"><li style="border:0px;vertical-align:baseline;line-height:1.8em;background:transparent;"><br>开始了解Git</li><li style="border:0px;vertical-align:baseline;line-height:1.8em;background:transparent;"></li></ol></p>
<p><ol style="border:0px;vertical-align:baseline;list-style:none;background:transparent;"><li style="border:0px;vertical-align:baseline;line-height:1.8em;background:transparent;"><br><span class="tocnumber" style="border:0px;vertical-align:baseline;background:transparent;">1.&nbsp;</span><a href="http://www.nowamagic.net/academy/detail/48160203" rel="nofollow" style="color:rgb(0,153,204);text-decoration:none;border:0px;vertical-align:baseline;background:transparent;" target="_blank">先谈谈版本控制的一些事</a></li><li style="border:0px;vertical-align:baseline;line-height:1.8em;background:transparent;"><br><span class="tocnumber" style="border:0px;vertical-align:baseline;background:transparent;">2.&nbsp;</span><a href="http://www.nowamagic.net/academy/detail/48160205" rel="nofollow" style="color:rgb(0,153,204);text-decoration:none;border:0px;vertical-align:baseline;background:transparent;" target="_blank">Git诞生背后的一些故事</a></li><li style="border:0px;vertical-align:baseline;line-height:1.8em;background:transparent;"><br><span class="tocnumber" style="border:0px;vertical-align:baseline;background:transparent;">3.&nbsp;</span><a href="http://www.nowamagic.net/academy/detail/48160207" rel="nofollow" style="color:rgb(0,153,204);text-decoration:none;border:0px;vertical-align:baseline;background:transparent;" target="_blank">版本控制：集中式VS分布式</a></li><li style="border:0px;vertical-align:baseline;line-height:1.8em;background:transparent;"><br><span class="tocnumber" style="border:0px;vertical-align:baseline;background:transparent;">4.&nbsp;</span><a href="http://www.nowamagic.net/academy/detail/48160210" rel="nofollow" style="color:rgb(0,153,204);text-decoration:none;border:0px;vertical-align:baseline;background:transparent;" target="_blank">Git的思想和基本工作原理</a></li><li style="border:0px;vertical-align:baseline;line-height:1.8em;background:transparent;"><br><span class="tocnumber" style="border:0px;vertical-align:baseline;background:transparent;">5.&nbsp;</span><a href="http://www.nowamagic.net/academy/detail/48160213" rel="nofollow" style="color:rgb(0,153,204);text-decoration:none;border:0px;vertical-align:baseline;background:transparent;" target="_blank">Git在Windows下的安装</a></li></ol></p>
<p><div class="aca_content" style="font-size:14px;border:0px;vertical-align:baseline;font-family:'PT Serif', Georgia, Times, 'Times New Roman', 'Heiti SC', 'Microsoft Yahei', '微软雅黑', '宋体', serif;color:rgb(26,37,54);line-height:21px;"></div></p>
<p style="border:0px;vertical-align:baseline;line-height:22px;letter-spacing:1px;text-indent:2em;background:transparent;"><br></p><br><p style="border:0px;vertical-align:baseline;line-height:22px;letter-spacing:1px;text-indent:2em;background:transparent;"><br>先说<a href="http://www.nowamagic.net/academy/tag/%E9%9B%86%E4%B8%AD%E5%BC%8F" rel="nofollow" style="color:rgb(0,153,204);text-decoration:none;border:0px;vertical-align:baseline;background:transparent;" target="_blank">集中式</a>版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。</p><br><div align="center" style="border:0px;vertical-align:baseline;background:transparent;"><br><img src="http://www.nowamagic.net/librarys/images/201401/2014_01_03_06.jpg" alt="" style="border:0px;vertical-align:baseline;background:transparent;"></div><br><p style="border:0px;vertical-align:baseline;line-height:22px;letter-spacing:1px;text-indent:2em;background:transparent;"><br>集中式版本控制系统最大的毛病就是必须联网才能工作，如果在局域网内还好，带宽够大，速度够快，可如果在互联网上，遇到网速慢的话，可能提交一个10M的文件就需要5分钟，这还不得把人给憋死啊。</p><br><p style="border:0px;vertical-align:baseline;line-height:22px;letter-spacing:1px;text-indent:2em;background:transparent;"><br>那<a href="http://www.nowamagic.net/academy/tag/%E5%88%86%E5%B8%83%E5%BC%8F" rel="nofollow" style="color:rgb(0,153,204);text-decoration:none;border:0px;vertical-align:baseline;background:transparent;" target="_blank">分布式</a>版本控制系统与集中式版本控制系统有何不同呢？首先，分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</p><br><p style="border:0px;vertical-align:baseline;line-height:22px;letter-spacing:1px;text-indent:2em;background:transparent;"><br>和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。</p><br><p style="border:0px;vertical-align:baseline;line-height:22px;letter-spacing:1px;text-indent:2em;background:transparent;"><br>在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不在一个局域网内，两台电脑互相访问不了，也可能今天你的同事病了，他的电脑压根没有开机。因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。</p><br><div align="center" style="border:0px;vertical-align:baseline;background:transparent;"><br><img src="http://www.nowamagic.net/librarys/images/201401/2014_01_03_07.jpg" alt="" style="border:0px;vertical-align:baseline;background:transparent;"></div><br><p style="border:0px;vertical-align:baseline;line-height:22px;letter-spacing:1px;text-indent:2em;background:transparent;"><br>当然，Git的优势不单是不必联网这么简单，后面我们还会看到Git极其强大的分支管理，把SVN等远远抛在了后面。</p><br><p style="border:0px;vertical-align:baseline;line-height:22px;letter-spacing:1px;text-indent:2em;background:transparent;"><br>CVS作为最早的开源而且免费的集中式版本控制系统，直到现在还有不少人在用。由于CVS自身设计的问题，会造成提交文件不完整，版本库莫名其妙损坏的情况。同样是开源而且免费的SVN修正了CVS的一些稳定性问题，是目前用得最多的集中式版本库控制系统。</p><br><p style="border:0px;vertical-align:baseline;line-height:22px;letter-spacing:1px;text-indent:2em;background:transparent;"><br>除了免费的外，还有收费的集中式版本控制系统，比如IBM的ClearCase（以前是Rational公司的，被IBM收购了），特点是安装比Windows还大，运行比蜗牛还慢，能用ClearCase的一般是世界500强，他们有个共同的特点是财大气粗，或者人傻钱多。</p><br><p style="border:0px;vertical-align:baseline;line-height:22px;letter-spacing:1px;text-indent:2em;background:transparent;"><br>微软自己也有一个集中式版本控制系统叫VSS，集成在Visual Studio中。由于其反人类的设计，连微软自己都不好意思用了。</p><br><p style="border:0px;vertical-align:baseline;line-height:22px;letter-spacing:1px;text-indent:2em;background:transparent;"><br>分布式版本控制系统除了Git以及促使Git诞生的BitKeeper外，还有类似Git的Mercurial和Bazaar等。这些分布式版本控制系统各有特点，但最快、最简单也最流行的依然是Git！</p>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/07/分布式和集中式的版本控制的区别/" data-id="ckb5166ax000mlsvwf5j5iyrc" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Articles récents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/06/07/c++创建对象带括号和不带括号的区别/">c++创建对象带括号和不带括号的区别</a>
          </li>
        
          <li>
            <a href="/2020/06/07/补充知识、线程池浅谈、数量谈、总结/">补充知识、线程池浅谈、数量谈、总结</a>
          </li>
        
          <li>
            <a href="/2020/06/07/windows临界区、其他各种mutex互斥量/">windows临界区、其他各种mutex互斥量</a>
          </li>
        
          <li>
            <a href="/2020/06/07/std-atomic续谈、std-async深入谈/">std::atomic续谈、std::async深入谈</a>
          </li>
        
          <li>
            <a href="/2020/06/07/future其他成员函数、shared-future、atomic/">future其他成员函数、shared_future、atomic</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Propulsé by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="/js/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>